<!DOCTYPE html>
<!-- saved from url=(0042)https://node-postgres.com/features/pooling -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="./node-postgres_ pooling_files/font-awesome.min.css">
    <link rel="stylesheet" href="./node-postgres_ pooling_files/bulma.min.css">
    <link rel="stylesheet" href="./node-postgres_ pooling_files/main.css">
    <script async="" src="./node-postgres_ pooling_files/analytics.js"></script><script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-100138145-1', 'auto');
  ga('send', 'pageview');
  window.ga = ga;
</script>
<script async="" src="./node-postgres_ pooling_files/f.txt"></script>
<script>
  (adsbygoogle = window.adsbygoogle || []).push({
    google_ad_client: "ca-pub-9771516987429412",
    enable_page_level_ads: true
  });
</script>

  <title>node-postgres: pooling</title><link rel="stylesheet" type="text/css" href="chrome-extension://pldlfgnilfdheajekfphjkjeooignhkc/css/general.css"></head>
  <body cz-shortcut-listen="true">
    <div id="root"><div data-reactroot="" data-reactid="1" data-react-checksum="-56784256"><div data-reactid="2"><nav class="navbar top-nav" data-reactid="3"><div class="navbar-start" data-reactid="4"><a class="navbar-item" href="https://node-postgres.com/" data-reactid="5">node-postgres</a></div><div class="navbar-end" data-reactid="6"><a target="_blank" class="navbar-item" href="https://www.patreon.com/node_postgres" data-reactid="7"><span class="icon" data-reactid="8"><i class="fa fa-star " style="margin-right:8px;color:#ffb745;" data-reactid="9"></i></span><span data-reactid="10">Support</span></a><a target="_blank" class="navbar-item" href="https://github.com/brianc/node-postgres" data-reactid="11"><span class="icon" data-reactid="12"><i class="fa fa-github" style="margin-right:8px;" data-reactid="13"></i></span><span data-reactid="14">GitHub</span></a></div></nav><div class="columns content-container" data-reactid="15"><div class="column is-2 section" data-reactid="16"><aside class="aside" data-reactid="17"><p class="menu-label" data-reactid="18"></p><ul class="menu-list" data-reactid="19"><li data-reactid="20"><a class="" href="https://node-postgres.com/" data-reactid="21">Welcome</a></li><li data-reactid="22"><a class="" href="https://node-postgres.com/announcements" data-reactid="23">Announcements</a></li></ul><p class="menu-label" data-reactid="24">Features</p><ul class="menu-list" data-reactid="25"><li data-reactid="26"><a class="" href="https://node-postgres.com/features/connecting" data-reactid="27">Connecting</a></li><li data-reactid="28"><a class="" href="https://node-postgres.com/features/queries" data-reactid="29">Queries</a></li><li data-reactid="30"><a class="is-active" href="https://node-postgres.com/features/pooling" data-reactid="31">Pooling</a></li><li data-reactid="32"><a class="" href="https://node-postgres.com/features/transactions" data-reactid="33">Transactions</a></li><li data-reactid="34"><a class="" href="https://node-postgres.com/features/types" data-reactid="35">Data Types</a></li><li data-reactid="36"><a class="" href="https://node-postgres.com/features/ssl" data-reactid="37">SSL/TLS</a></li><li data-reactid="38"><a class="" href="https://node-postgres.com/features/native" data-reactid="39">Native Bindings</a></li></ul><p class="menu-label" data-reactid="40">Guides</p><ul class="menu-list" data-reactid="41"><li data-reactid="42"><a class="" href="https://node-postgres.com/guides/project-structure" data-reactid="43">Project Structure</a></li><li data-reactid="44"><a class="" href="https://node-postgres.com/guides/async-express" data-reactid="45">Express + async/await</a></li><li data-reactid="46"><a class="" href="https://node-postgres.com/guides/upgrading" data-reactid="47">Upgrading to 7.0</a></li></ul><p class="menu-label" data-reactid="48">API Docs</p><ul class="menu-list" data-reactid="49"><li data-reactid="50"><a class="" href="https://node-postgres.com/api/pool" data-reactid="51">pg.Pool</a></li><li data-reactid="52"><a class="" href="https://node-postgres.com/api/client" data-reactid="53">pg.Client</a></li><li data-reactid="54"><a class="" href="https://node-postgres.com/api/result" data-reactid="55">pg.Result</a></li><li data-reactid="56"><a class="" href="https://node-postgres.com/api/types" data-reactid="57">types</a></li><li data-reactid="58"><a class="" href="https://node-postgres.com/api/cursor" data-reactid="59">Cursor</a></li><li data-reactid="60"><a class="" href="https://node-postgres.com/api/query-stream" data-reactid="61">QueryStream</a></li><li data-reactid="62"><a class="" href="https://node-postgres.com/api/copy-streams" data-reactid="63">Copy Streams</a></li></ul></aside></div><div class="column section doc-content" data-reactid="64"><div data-reactid="65"><div class="content" data-reactid="66"><h1><a name="pooling" class="anchor" href="https://node-postgres.com/features/pooling#pooling"><i class="fa fa-link"></i></a>Pooling</h1><p>If you're working on a web application or other software which makes frequent queries you'll want to use a connection pool.</p>
<p>The easiest and by far most common way to use node-postgres is through a connection pool.</p>
<h2><a name="why-" class="anchor" href="https://node-postgres.com/features/pooling#why-"><i class="fa fa-link"></i></a>Why?</h2><ul>
<li><p>Connecting a new client to the PostgreSQL server requires a handshake which can take 20-30 milliseconds.  During this time passwords are negotiated, SSL may be established, and configuration information is shared with the client &amp; server.  Incurring this cost <em>every time</em> we want to execute a query would substantially slow down our application.</p>
</li>
<li><p>The PostgreSQL server can only handle a <a href="https://wiki.postgresql.org/wiki/Number_Of_Database_Connections" target="_blank" title="null">limited number of clients at a time</a>.  Depending on the available memory of your PostgreSQL server you may even crash the server if you connect an unbounded number of clients. <em>note: I have crashed a large production PostgreSQL server instance in RDS by opening new clients and never disconnecting them in a python application long ago. It was not fun.</em></p>
</li>
<li><p>PostgreSQL can only process one query at a time on a single connected client in a first-in first-out manner.  If your multi-tenant web application is using only a single connected client all queries among all simultaneous requests will be pipelined and executed serially, one after the other.  No good!</p>
</li>
</ul>
<h3><a name="good-news" class="anchor" href="https://node-postgres.com/features/pooling#good-news"><i class="fa fa-link"></i></a>Good news</h3><p>node-postgres ships with built-in connection pooling via the <a href="https://node-postgres.com/features/pooling" target="_blank" title="null">pg-pool</a> module.</p>
<h2><a name="examples" class="anchor" href="https://node-postgres.com/features/pooling#examples"><i class="fa fa-link"></i></a>Examples</h2><p>The client pool allows you to have a reusable pool of clients you can check out, use, and return.  You generally want a limited number of these in your application and usually just 1. Creating an unbounded number of pools defeats the purpose of pooling at all.</p>
<h3><a name="checkout-use-and-return" class="anchor" href="https://node-postgres.com/features/pooling#checkout-use-and-return"><i class="fa fa-link"></i></a>Checkout, use, and return</h3><pre><code class="lang-js"><span class="hljs-keyword">const</span> { Pool } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'pg'</span>)

<span class="hljs-keyword">const</span> pool = <span class="hljs-keyword">new</span> Pool()

<span class="hljs-comment">// the pool with emit an error on behalf of any idle clients</span>
<span class="hljs-comment">// it contains if a backend error or network partition happens</span>
pool.on(<span class="hljs-string">'error'</span>, <span class="hljs-function">(<span class="hljs-params">err, client</span>) =&gt;</span> {
  <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'Unexpected error on idle client'</span>, err)
  process.exit(<span class="hljs-number">-1</span>)
})

<span class="hljs-comment">// callback - checkout a client</span>
pool.connect(<span class="hljs-function">(<span class="hljs-params">err, client, done</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err
  client.query(<span class="hljs-string">'SELECT * FROM users WHERE id = $1'</span>, [<span class="hljs-number">1</span>], <span class="hljs-function">(<span class="hljs-params">err, res</span>) =&gt;</span> {
    done()

    <span class="hljs-keyword">if</span> (err) {
      <span class="hljs-built_in">console</span>.log(err.stack)
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-built_in">console</span>.log(res.rows[<span class="hljs-number">0</span>])
    }
  })
})

<span class="hljs-comment">// promise - checkout a client</span>
pool.connect()
  .then(<span class="hljs-function"><span class="hljs-params">client</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> client.query(<span class="hljs-string">'SELECT * FROM users WHERE id = $1'</span>, [<span class="hljs-number">1</span>])
      .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> {
        client.release()
        <span class="hljs-built_in">console</span>.log(res.rows[<span class="hljs-number">0</span>])
      })
      .catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
        client.release()
        <span class="hljs-built_in">console</span>.log(err.stack)
      })
  })

<span class="hljs-comment">// async/await - check out a client</span>
(<span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">const</span> client = <span class="hljs-keyword">await</span> pool.connect()
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> client.query(<span class="hljs-string">'SELECT * FROM users WHERE id = $1'</span>, [<span class="hljs-number">1</span>])
    <span class="hljs-built_in">console</span>.log(res.rows[<span class="hljs-number">0</span>])
  } <span class="hljs-keyword">finally</span> {
    client.release()
  }
})().catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(e.stack))
</code></pre>
<div class="message is-danger">
  <div class="message-body">
    You must <strong>always</strong> return the client to the pool if you successfully check it out, regardless of whether or not there was an error with the queries you ran on the client.  If you don't check in the client your application will leak them and eventually your pool will be empty forever and all future requests to check out a client from the pool will wait forever.
  </div>
</div>

<h3><a name="single-query" class="anchor" href="https://node-postgres.com/features/pooling#single-query"><i class="fa fa-link"></i></a>Single query</h3><p>If you don't need a transaction or you just need to run a single query, the pool has a convenience method to run a query on any available client in the pool.  This is the preferred way to query with node-postgres if you can as it removes the risk of leaking a client.</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> { Pool } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'pg'</span>)

<span class="hljs-keyword">const</span> pool = <span class="hljs-keyword">new</span> Pool()

pool.query(<span class="hljs-string">'SELECT * FROM users WHERE id = $1'</span>, [<span class="hljs-number">1</span>], <span class="hljs-function">(<span class="hljs-params">err, res</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) {
    <span class="hljs-keyword">throw</span> err
  }

  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'user:'</span>, res.rows[<span class="hljs-number">0</span>])
})
</code></pre>
<p>node-postgres also has built-in support for promises throughout all of its async APIs.</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> { Pool } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'pg'</span>)

<span class="hljs-keyword">const</span> pool = <span class="hljs-keyword">new</span> Pool()

pool.query(<span class="hljs-string">'SELECT * FROM users WHERE id = $1'</span>, [<span class="hljs-number">1</span>])
  .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'user:'</span>, res.rows[<span class="hljs-number">0</span>]))
  .catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> setImmediate(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> { <span class="hljs-keyword">throw</span> e }))
</code></pre>
<p>Promises allow us to use <code>async</code>/<code>await</code> in node v8.0 and above (or earlier if you're using babel).</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> { Pool } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'pg'</span>)
<span class="hljs-keyword">const</span> pool = <span class="hljs-keyword">new</span> Pool()

(<span class="hljs-keyword">async</span> () =&gt; {

  <span class="hljs-keyword">const</span> { rows } = <span class="hljs-keyword">await</span> pool.query(<span class="hljs-string">'SELECT * FROM users WHERE id = $1'</span>, [<span class="hljs-number">1</span>])
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'user:'</span>, rows[<span class="hljs-number">0</span>])

})().catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> setImmediate(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> { <span class="hljs-keyword">throw</span> e }))
</code></pre>
<h3><a name="shutdown" class="anchor" href="https://node-postgres.com/features/pooling#shutdown"><i class="fa fa-link"></i></a>Shutdown</h3><p>To shut down a pool call <code>pool.end()</code> on the pool.  This will wait for all checked-out clients to be returned and then shut down all the clients and the pool timers.</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> { Pool } = require('pg')
<span class="hljs-keyword">const</span> pool = new Pool()

(async () =&gt; {
  console.<span class="hljs-built_in">log</span>('starting async <span class="hljs-keyword">query</span>')
  <span class="hljs-keyword">const</span> result = await pool.<span class="hljs-keyword">query</span>('SELECT NOW()')
  console.<span class="hljs-built_in">log</span>('async <span class="hljs-keyword">query</span> finished)

  console.<span class="hljs-built_in">log</span>('starting callback <span class="hljs-keyword">query</span>')
  pool.<span class="hljs-keyword">query</span>('SELECT NOW()', (<span class="hljs-keyword">err</span>, res) =&gt; {
    console.<span class="hljs-built_in">log</span>('callback <span class="hljs-keyword">query</span> finished')
  })

  console.<span class="hljs-built_in">log</span>('calling end')
  await pool.end()
  console.<span class="hljs-built_in">log</span>('pool has drained')
})()
</code></pre>
<p>The output of the above will be:</p>
<pre><code>starting async <span class="hljs-keyword">query</span>
async <span class="hljs-keyword">query</span> finished
starting callback <span class="hljs-keyword">query</span>
calling <span class="hljs-keyword">end</span>
callback <span class="hljs-keyword">query</span> finished
pool has drained
</code></pre><div class="message is-warning">
  <div class="message-body">
    The pool will return errors when attempting to check out a client after you've called <code>pool.end()</code> on the pool.
  </div>
</div>
</div></div></div></div><div class="level is-mobile" style="color:#AAA;font-size:12px;padding-bottom:20px;" data-reactid="67"><div class="level-item has-text-centered" data-reactid="68"><span data-reactid="69"><span data-reactid="70">made with</span><i class="fa fa-heart " style="padding:0 5px;color:pink;" data-reactid="71"></i><span style="padding-right:5px;" data-reactid="72">by</span><a href="https://twitter.com/briancarlson" target="_blank" data-reactid="73">@briancarlson</a></span></div></div></div></div></div>
    <script src="./node-postgres_ pooling_files/client.bundle.js"></script>
  

</body></html>